const randomStr = (length = 10) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    const charactersLength = characters.length;
    let counter = 0;
    while (counter < length) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
      counter += 1;
    }
    return result;
};

const checkCollisions = (movingDiv) =>{
      var found = null;
      document.querySelectorAll('.node').forEach(div => {
        if (div !== movingDiv && !isBeingDragged(div) && isWithinRadius(movingDiv, div, 400)) {
          found = div;
        }
      });
      return found;
    };

const calculateDistance = (x1, y1, x2, y2) => {
  let dx = x2 - x1;
  let dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
};

// This function checks if one div is within the radius of another div
const isWithinRadius = (div1, div2, radius) => {
      const rect1 = div1.getBoundingClientRect();
      const rect2 = div2.getBoundingClientRect();
      const centerX1 = rect1.left + rect1.width / 2;
      const centerY1 = rect1.top + rect1.height / 2;
      const centerX2 = rect2.left + rect2.width / 2;
      const centerY2 = rect2.top + rect2.height / 2;

      const distance = calculateDistance(centerX1, centerY1, centerX2, centerY2);
      return distance <= radius;    
    };

    // Função para verificar se uma div está em movimento
const isBeingDragged = (div) =>{
  return div === document.querySelector('.dragging');
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var dist = {exports: {}};

var symbol_iterator = function SymbolIterator() {
  var _this = this;

  var index = -1;
  return {
    next: function next() {
      index += 1;
      return {
        value: _this.items[index],
        done: index >= _this.items.length
      };
    }
  };
};

var all = function all() {
  return this.items;
};

function _typeof$a(obj) { "@babel/helpers - typeof"; return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$a(obj); }

var is = {
  /**
   * @returns {boolean}
   */
  isArray: function isArray(item) {
    return Array.isArray(item);
  },

  /**
   * @returns {boolean}
   */
  isObject: function isObject(item) {
    return _typeof$a(item) === 'object' && Array.isArray(item) === false && item !== null;
  },

  /**
   * @returns {boolean}
   */
  isFunction: function isFunction(item) {
    return typeof item === 'function';
  }
};

var _require$m = is,
    isFunction$h = _require$m.isFunction;

var average$1 = function average(key) {
  if (key === undefined) {
    return this.sum() / this.items.length;
  }

  if (isFunction$h(key)) {
    return new this.constructor(this.items).sum(key) / this.items.length;
  }

  return new this.constructor(this.items).pluck(key).sum() / this.items.length;
};

var average = average$1;

var avg = average;

function _typeof$9(obj) { "@babel/helpers - typeof"; return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$9(obj); }

var chunk = function chunk(size) {
  var _this = this;

  var chunks = [];
  var index = 0;

  if (Array.isArray(this.items)) {
    do {
      var items = this.items.slice(index, index + size);
      var collection = new this.constructor(items);
      chunks.push(collection);
      index += size;
    } while (index < this.items.length);
  } else if (_typeof$9(this.items) === 'object') {
    var keys = Object.keys(this.items);

    var _loop = function _loop() {
      var keysOfChunk = keys.slice(index, index + size);
      var collection = new _this.constructor({});
      keysOfChunk.forEach(function (key) {
        return collection.put(key, _this.items[key]);
      });
      chunks.push(collection);
      index += size;
    };

    do {
      _loop();
    } while (index < keys.length);
  } else {
    chunks.push(new this.constructor([this.items]));
  }

  return new this.constructor(chunks);
};

function _toConsumableArray$7(arr) { return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$b(arr) || _nonIterableSpread$7(); }

function _nonIterableSpread$7() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$b(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$b(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen); }

function _iterableToArray$7(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles$7(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$b(arr); }

function _arrayLikeToArray$b(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var collapse = function collapse() {
  var _ref;

  return new this.constructor((_ref = []).concat.apply(_ref, _toConsumableArray$7(this.items)));
};

function _slicedToArray$3(arr, i) { return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$a(arr, i) || _nonIterableRest$3(); }

function _nonIterableRest$3() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }

function _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit$3(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles$3(arr) { if (Array.isArray(arr)) return arr; }

function _typeof$8(obj) { "@babel/helpers - typeof"; return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$8(obj); }

var combine = function combine(array) {
  var _this = this;

  var values = array;

  if (values instanceof this.constructor) {
    values = array.all();
  }

  var collection = {};

  if (Array.isArray(this.items) && Array.isArray(values)) {
    this.items.forEach(function (key, iterator) {
      collection[key] = values[iterator];
    });
  } else if (_typeof$8(this.items) === 'object' && _typeof$8(values) === 'object') {
    Object.keys(this.items).forEach(function (key, index) {
      collection[_this.items[key]] = values[Object.keys(values)[index]];
    });
  } else if (Array.isArray(this.items)) {
    collection[this.items[0]] = values;
  } else if (typeof this.items === 'string' && Array.isArray(values)) {
    var _values = values;

    var _values2 = _slicedToArray$3(_values, 1);

    collection[this.items] = _values2[0];
  } else if (typeof this.items === 'string') {
    collection[this.items] = values;
  }

  return new this.constructor(collection);
};

/**
 * Clone helper
 *
 * Clone an array or object
 *
 * @param items
 * @returns {*}
 */

function _toConsumableArray$6(arr) { return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread$6(); }

function _nonIterableSpread$6() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }

function _iterableToArray$6(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles$6(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$9(arr); }

function _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var clone$2 = function clone(items) {
  var cloned;

  if (Array.isArray(items)) {
    var _cloned;

    cloned = [];

    (_cloned = cloned).push.apply(_cloned, _toConsumableArray$6(items));
  } else {
    cloned = {};
    Object.keys(items).forEach(function (prop) {
      cloned[prop] = items[prop];
    });
  }

  return cloned;
};

function _typeof$7(obj) { "@babel/helpers - typeof"; return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$7(obj); }

var clone$1 = clone$2;

var concat = function concat(collectionOrArrayOrObject) {
  var list = collectionOrArrayOrObject;

  if (collectionOrArrayOrObject instanceof this.constructor) {
    list = collectionOrArrayOrObject.all();
  } else if (_typeof$7(collectionOrArrayOrObject) === 'object') {
    list = [];
    Object.keys(collectionOrArrayOrObject).forEach(function (property) {
      list.push(collectionOrArrayOrObject[property]);
    });
  }

  var collection = clone$1(this.items);
  list.forEach(function (item) {
    if (_typeof$7(item) === 'object') {
      Object.keys(item).forEach(function (key) {
        return collection.push(item[key]);
      });
    } else {
      collection.push(item);
    }
  });
  return new this.constructor(collection);
};

/**
 * Values helper
 *
 * Retrieve values from [this.items] when it is an array, object or Collection
 *
 * @param items
 * @returns {*}
 */

function _toConsumableArray$5(arr) { return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$5(); }

function _nonIterableSpread$5() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

function _iterableToArray$5(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles$5(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$8(arr); }

function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var values$8 = function values(items) {
  var valuesArray = [];

  if (Array.isArray(items)) {
    valuesArray.push.apply(valuesArray, _toConsumableArray$5(items));
  } else if (items.constructor.name === 'Collection') {
    valuesArray.push.apply(valuesArray, _toConsumableArray$5(items.all()));
  } else {
    Object.keys(items).forEach(function (prop) {
      return valuesArray.push(items[prop]);
    });
  }

  return valuesArray;
};

function _toConsumableArray$4(arr) { return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$4(); }

function _nonIterableSpread$4() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

function _iterableToArray$4(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles$4(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$7(arr); }

function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var values$7 = values$8;

var _require$l = is,
    isFunction$g = _require$l.isFunction;

var contains$1 = function contains(key, value) {
  if (value !== undefined) {
    if (Array.isArray(this.items)) {
      return this.items.filter(function (items) {
        return items[key] !== undefined && items[key] === value;
      }).length > 0;
    }

    return this.items[key] !== undefined && this.items[key] === value;
  }

  if (isFunction$g(key)) {
    return this.items.filter(function (item, index) {
      return key(item, index);
    }).length > 0;
  }

  if (Array.isArray(this.items)) {
    return this.items.indexOf(key) !== -1;
  }

  var keysAndValues = values$7(this.items);
  keysAndValues.push.apply(keysAndValues, _toConsumableArray$4(Object.keys(this.items)));
  return keysAndValues.indexOf(key) !== -1;
};

var containsOneItem = function containsOneItem() {
  return this.count() === 1;
};

var count = function count() {
  var arrayLength = 0;

  if (Array.isArray(this.items)) {
    arrayLength = this.items.length;
  }

  return Math.max(Object.keys(this.items).length, arrayLength);
};

var countBy = function countBy() {
  var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (value) {
    return value;
  };
  return new this.constructor(this.items).groupBy(fn).map(function (value) {
    return value.count();
  });
};

var crossJoin = function crossJoin() {
  function join(collection, constructor, args) {
    var current = args[0];

    if (current instanceof constructor) {
      current = current.all();
    }

    var rest = args.slice(1);
    var last = !rest.length;
    var result = [];

    for (var i = 0; i < current.length; i += 1) {
      var collectionCopy = collection.slice();
      collectionCopy.push(current[i]);

      if (last) {
        result.push(collectionCopy);
      } else {
        result = result.concat(join(collectionCopy, constructor, rest));
      }
    }

    return result;
  }

  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  return new this.constructor(join([], this.constructor, [].concat([this.items], values)));
};

var dd = function dd() {
  this.dump();

  if (typeof process !== 'undefined') {
    process.exit(1);
  }
};

var diff = function diff(values) {
  var valuesToDiff;

  if (values instanceof this.constructor) {
    valuesToDiff = values.all();
  } else {
    valuesToDiff = values;
  }

  var collection = this.items.filter(function (item) {
    return valuesToDiff.indexOf(item) === -1;
  });
  return new this.constructor(collection);
};

var diffAssoc = function diffAssoc(values) {
  var _this = this;

  var diffValues = values;

  if (values instanceof this.constructor) {
    diffValues = values.all();
  }

  var collection = {};
  Object.keys(this.items).forEach(function (key) {
    if (diffValues[key] === undefined || diffValues[key] !== _this.items[key]) {
      collection[key] = _this.items[key];
    }
  });
  return new this.constructor(collection);
};

var diffKeys = function diffKeys(object) {
  var objectToDiff;

  if (object instanceof this.constructor) {
    objectToDiff = object.all();
  } else {
    objectToDiff = object;
  }

  var objectKeys = Object.keys(objectToDiff);
  var remainingKeys = Object.keys(this.items).filter(function (item) {
    return objectKeys.indexOf(item) === -1;
  });
  return new this.constructor(this.items).only(remainingKeys);
};

var diffUsing = function diffUsing(values, callback) {
  var collection = this.items.filter(function (item) {
    return !(values && values.some(function (otherItem) {
      return callback(item, otherItem) === 0;
    }));
  });
  return new this.constructor(collection);
};

var doesntContain = function contains(key, value) {
  return !this.contains(key, value);
};

var dump = function dump() {
  // eslint-disable-next-line
  console.log(this);
  return this;
};

function _typeof$6(obj) { "@babel/helpers - typeof"; return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$6(obj); }

var duplicates = function duplicates() {
  var _this = this;

  var occuredValues = [];
  var duplicateValues = {};

  var stringifiedValue = function stringifiedValue(value) {
    if (Array.isArray(value) || _typeof$6(value) === 'object') {
      return JSON.stringify(value);
    }

    return value;
  };

  if (Array.isArray(this.items)) {
    this.items.forEach(function (value, index) {
      var valueAsString = stringifiedValue(value);

      if (occuredValues.indexOf(valueAsString) === -1) {
        occuredValues.push(valueAsString);
      } else {
        duplicateValues[index] = value;
      }
    });
  } else if (_typeof$6(this.items) === 'object') {
    Object.keys(this.items).forEach(function (key) {
      var valueAsString = stringifiedValue(_this.items[key]);

      if (occuredValues.indexOf(valueAsString) === -1) {
        occuredValues.push(valueAsString);
      } else {
        duplicateValues[key] = _this.items[key];
      }
    });
  }

  return new this.constructor(duplicateValues);
};

var each = function each(fn) {
  var stop = false;

  if (Array.isArray(this.items)) {
    var length = this.items.length;

    for (var index = 0; index < length && !stop; index += 1) {
      stop = fn(this.items[index], index, this.items) === false;
    }
  } else {
    var keys = Object.keys(this.items);
    var _length = keys.length;

    for (var _index = 0; _index < _length && !stop; _index += 1) {
      var key = keys[_index];
      stop = fn(this.items[key], key, this.items) === false;
    }
  }

  return this;
};

function _toConsumableArray$3(arr) { return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$3(); }

function _nonIterableSpread$3() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

function _iterableToArray$3(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles$3(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$6(arr); }

function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var eachSpread = function eachSpread(fn) {
  this.each(function (values, key) {
    fn.apply(void 0, _toConsumableArray$3(values).concat([key]));
  });
  return this;
};

var values$6 = values$8;

var every = function every(fn) {
  var items = values$6(this.items);
  return items.every(fn);
};

/**
 * Variadic helper function
 *
 * @param args
 * @returns {Array}
 */

var variadic$4 = function variadic(args) {
  if (Array.isArray(args[0])) {
    return args[0];
  }

  return args;
};

var variadic$3 = variadic$4;

var except = function except() {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var properties = variadic$3(args);

  if (Array.isArray(this.items)) {
    var _collection = this.items.filter(function (item) {
      return properties.indexOf(item) === -1;
    });

    return new this.constructor(_collection);
  }

  var collection = {};
  Object.keys(this.items).forEach(function (property) {
    if (properties.indexOf(property) === -1) {
      collection[property] = _this.items[property];
    }
  });
  return new this.constructor(collection);
};

function _typeof$5(obj) { "@babel/helpers - typeof"; return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$5(obj); }

function falsyValue(item) {
  if (Array.isArray(item)) {
    if (item.length) {
      return false;
    }
  } else if (item !== undefined && item !== null && _typeof$5(item) === 'object') {
    if (Object.keys(item).length) {
      return false;
    }
  } else if (item) {
    return false;
  }

  return true;
}

function filterObject(func, items) {
  var result = {};
  Object.keys(items).forEach(function (key) {
    if (func) {
      if (func(items[key], key)) {
        result[key] = items[key];
      }
    } else if (!falsyValue(items[key])) {
      result[key] = items[key];
    }
  });
  return result;
}

function filterArray(func, items) {
  if (func) {
    return items.filter(func);
  }

  var result = [];

  for (var i = 0; i < items.length; i += 1) {
    var item = items[i];

    if (!falsyValue(item)) {
      result.push(item);
    }
  }

  return result;
}

var filter = function filter(fn) {
  var func = fn || false;
  var filteredItems = null;

  if (Array.isArray(this.items)) {
    filteredItems = filterArray(func, this.items);
  } else {
    filteredItems = filterObject(func, this.items);
  }

  return new this.constructor(filteredItems);
};

var _require$k = is,
    isFunction$f = _require$k.isFunction;

var first = function first(fn, defaultValue) {
  if (isFunction$f(fn)) {
    var keys = Object.keys(this.items);

    for (var i = 0; i < keys.length; i += 1) {
      var key = keys[i];
      var item = this.items[key];

      if (fn(item, key)) {
        return item;
      }
    }

    if (isFunction$f(defaultValue)) {
      return defaultValue();
    }

    return defaultValue;
  }

  if (Array.isArray(this.items) && this.items.length || Object.keys(this.items).length) {
    if (Array.isArray(this.items)) {
      return this.items[0];
    }

    var firstKey = Object.keys(this.items)[0];
    return this.items[firstKey];
  }

  if (isFunction$f(defaultValue)) {
    return defaultValue();
  }

  return defaultValue;
};

var _require$j = is,
    isFunction$e = _require$j.isFunction;

var firstOrFail = function firstOrFail(key, operator, value) {
  if (isFunction$e(key)) {
    return this.first(key, function () {
      throw new Error('Item not found.');
    });
  }

  var collection = this.where(key, operator, value);

  if (collection.isEmpty()) {
    throw new Error('Item not found.');
  }

  return collection.first();
};

var firstWhere = function firstWhere(key, operator, value) {
  return this.where(key, operator, value).first() || null;
};

var flatMap = function flatMap(fn) {
  return this.map(fn).collapse();
};

var _require$i = is,
    isArray$8 = _require$i.isArray,
    isObject$9 = _require$i.isObject;

var flatten = function flatten(depth) {
  var flattenDepth = depth || Infinity;
  var fullyFlattened = false;
  var collection = [];

  var flat = function flat(items) {
    collection = [];

    if (isArray$8(items)) {
      items.forEach(function (item) {
        if (isArray$8(item)) {
          collection = collection.concat(item);
        } else if (isObject$9(item)) {
          Object.keys(item).forEach(function (property) {
            collection = collection.concat(item[property]);
          });
        } else {
          collection.push(item);
        }
      });
    } else {
      Object.keys(items).forEach(function (property) {
        if (isArray$8(items[property])) {
          collection = collection.concat(items[property]);
        } else if (isObject$9(items[property])) {
          Object.keys(items[property]).forEach(function (prop) {
            collection = collection.concat(items[property][prop]);
          });
        } else {
          collection.push(items[property]);
        }
      });
    }

    fullyFlattened = collection.filter(function (item) {
      return isObject$9(item);
    });
    fullyFlattened = fullyFlattened.length === 0;
    flattenDepth -= 1;
  };

  flat(this.items);

  while (!fullyFlattened && flattenDepth > 0) {
    flat(collection);
  }

  return new this.constructor(collection);
};

var flip = function flip() {
  var _this = this;

  var collection = {};

  if (Array.isArray(this.items)) {
    Object.keys(this.items).forEach(function (key) {
      collection[_this.items[key]] = Number(key);
    });
  } else {
    Object.keys(this.items).forEach(function (key) {
      collection[_this.items[key]] = key;
    });
  }

  return new this.constructor(collection);
};

var forPage = function forPage(page, chunk) {
  var _this = this;

  var collection = {};

  if (Array.isArray(this.items)) {
    collection = this.items.slice(page * chunk - chunk, page * chunk);
  } else {
    Object.keys(this.items).slice(page * chunk - chunk, page * chunk).forEach(function (key) {
      collection[key] = _this.items[key];
    });
  }

  return new this.constructor(collection);
};

var forget = function forget(key) {
  if (Array.isArray(this.items)) {
    this.items.splice(key, 1);
  } else {
    delete this.items[key];
  }

  return this;
};

var _require$h = is,
    isFunction$d = _require$h.isFunction;

var get = function get(key) {
  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (this.items[key] !== undefined) {
    return this.items[key];
  }

  if (isFunction$d(defaultValue)) {
    return defaultValue();
  }

  if (defaultValue !== null) {
    return defaultValue;
  }

  return null;
};

/**
 * Get value of a nested property
 *
 * @param mainObject
 * @param key
 * @returns {*}
 */

var nestedValue$8 = function nestedValue(mainObject, key) {
  try {
    return key.split('.').reduce(function (obj, property) {
      return obj[property];
    }, mainObject);
  } catch (err) {
    // If we end up here, we're not working with an object, and @var mainObject is the value itself
    return mainObject;
  }
};

var nestedValue$7 = nestedValue$8;

var _require$g = is,
    isFunction$c = _require$g.isFunction;

var groupBy = function groupBy(key) {
  var _this = this;

  var collection = {};
  this.items.forEach(function (item, index) {
    var resolvedKey;

    if (isFunction$c(key)) {
      resolvedKey = key(item, index);
    } else if (nestedValue$7(item, key) || nestedValue$7(item, key) === 0) {
      resolvedKey = nestedValue$7(item, key);
    } else {
      resolvedKey = '';
    }

    if (collection[resolvedKey] === undefined) {
      collection[resolvedKey] = new _this.constructor([]);
    }

    collection[resolvedKey].push(item);
  });
  return new this.constructor(collection);
};

var variadic$2 = variadic$4;

var has = function has() {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var properties = variadic$2(args);
  return properties.filter(function (key) {
    return Object.hasOwnProperty.call(_this.items, key);
  }).length === properties.length;
};

var implode = function implode(key, glue) {
  if (glue === undefined) {
    return this.items.join(key);
  }

  return new this.constructor(this.items).pluck(key).all().join(glue);
};

var intersect = function intersect(values) {
  var intersectValues = values;

  if (values instanceof this.constructor) {
    intersectValues = values.all();
  }

  var collection = this.items.filter(function (item) {
    return intersectValues.indexOf(item) !== -1;
  });
  return new this.constructor(collection);
};

var intersectByKeys = function intersectByKeys(values) {
  var _this = this;

  var intersectKeys = Object.keys(values);

  if (values instanceof this.constructor) {
    intersectKeys = Object.keys(values.all());
  }

  var collection = {};
  Object.keys(this.items).forEach(function (key) {
    if (intersectKeys.indexOf(key) !== -1) {
      collection[key] = _this.items[key];
    }
  });
  return new this.constructor(collection);
};

var isEmpty = function isEmpty() {
  if (Array.isArray(this.items)) {
    return !this.items.length;
  }

  return !Object.keys(this.items).length;
};

var isNotEmpty = function isNotEmpty() {
  return !this.isEmpty();
};

var join = function join(glue, finalGlue) {
  var collection = this.values();

  if (finalGlue === undefined) {
    return collection.implode(glue);
  }

  var count = collection.count();

  if (count === 0) {
    return '';
  }

  if (count === 1) {
    return collection.last();
  }

  var finalItem = collection.pop();
  return collection.implode(glue) + finalGlue + finalItem;
};

var nestedValue$6 = nestedValue$8;

var _require$f = is,
    isFunction$b = _require$f.isFunction;

var keyBy = function keyBy(key) {
  var collection = {};

  if (isFunction$b(key)) {
    this.items.forEach(function (item) {
      collection[key(item)] = item;
    });
  } else {
    this.items.forEach(function (item) {
      var keyValue = nestedValue$6(item, key);
      collection[keyValue || ''] = item;
    });
  }

  return new this.constructor(collection);
};

var keys = function keys() {
  var collection = Object.keys(this.items);

  if (Array.isArray(this.items)) {
    collection = collection.map(Number);
  }

  return new this.constructor(collection);
};

var _require$e = is,
    isFunction$a = _require$e.isFunction;

var last = function last(fn, defaultValue) {
  var items = this.items;

  if (isFunction$a(fn)) {
    items = this.filter(fn).all();
  }

  if (Array.isArray(items) && !items.length || !Object.keys(items).length) {
    if (isFunction$a(defaultValue)) {
      return defaultValue();
    }

    return defaultValue;
  }

  if (Array.isArray(items)) {
    return items[items.length - 1];
  }

  var keys = Object.keys(items);
  return items[keys[keys.length - 1]];
};

var macro = function macro(name, fn) {
  this.constructor.prototype[name] = fn;
};

var make = function make() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return new this.constructor(items);
};

var map = function map(fn) {
  var _this = this;

  if (Array.isArray(this.items)) {
    return new this.constructor(this.items.map(fn));
  }

  var collection = {};
  Object.keys(this.items).forEach(function (key) {
    collection[key] = fn(_this.items[key], key);
  });
  return new this.constructor(collection);
};

function _toConsumableArray$2(arr) { return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$2(); }

function _nonIterableSpread$2() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

function _iterableToArray$2(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles$2(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$5(arr); }

function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var mapSpread = function mapSpread(fn) {
  return this.map(function (values, key) {
    return fn.apply(void 0, _toConsumableArray$2(values).concat([key]));
  });
};

function _slicedToArray$2(arr, i) { return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$2(); }

function _nonIterableRest$2() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit$2(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles$2(arr) { if (Array.isArray(arr)) return arr; }

var mapToDictionary = function mapToDictionary(fn) {
  var collection = {};
  this.items.forEach(function (item, k) {
    var _fn = fn(item, k),
        _fn2 = _slicedToArray$2(_fn, 2),
        key = _fn2[0],
        value = _fn2[1];

    if (collection[key] === undefined) {
      collection[key] = [value];
    } else {
      collection[key].push(value);
    }
  });
  return new this.constructor(collection);
};

var mapInto = function mapInto(ClassName) {
  return this.map(function (value, key) {
    return new ClassName(value, key);
  });
};

function _slicedToArray$1(arr, i) { return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$1(); }

function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit$1(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }

var mapToGroups = function mapToGroups(fn) {
  var collection = {};
  this.items.forEach(function (item, key) {
    var _fn = fn(item, key),
        _fn2 = _slicedToArray$1(_fn, 2),
        keyed = _fn2[0],
        value = _fn2[1];

    if (collection[keyed] === undefined) {
      collection[keyed] = [value];
    } else {
      collection[keyed].push(value);
    }
  });
  return new this.constructor(collection);
};

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var mapWithKeys = function mapWithKeys(fn) {
  var _this = this;

  var collection = {};

  if (Array.isArray(this.items)) {
    this.items.forEach(function (item, index) {
      var _fn = fn(item, index),
          _fn2 = _slicedToArray(_fn, 2),
          keyed = _fn2[0],
          value = _fn2[1];

      collection[keyed] = value;
    });
  } else {
    Object.keys(this.items).forEach(function (key) {
      var _fn3 = fn(_this.items[key], key),
          _fn4 = _slicedToArray(_fn3, 2),
          keyed = _fn4[0],
          value = _fn4[1];

      collection[keyed] = value;
    });
  }

  return new this.constructor(collection);
};

function _toConsumableArray$1(arr) { return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1(); }

function _nonIterableSpread$1() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _iterableToArray$1(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles$1(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$1(arr); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var max = function max(key) {
  if (typeof key === 'string') {
    var filtered = this.items.filter(function (item) {
      return item[key] !== undefined;
    });
    return Math.max.apply(Math, _toConsumableArray$1(filtered.map(function (item) {
      return item[key];
    })));
  }

  return Math.max.apply(Math, _toConsumableArray$1(this.items));
};

var median = function median(key) {
  var length = this.items.length;

  if (key === undefined) {
    if (length % 2 === 0) {
      return (this.items[length / 2 - 1] + this.items[length / 2]) / 2;
    }

    return this.items[Math.floor(length / 2)];
  }

  if (length % 2 === 0) {
    return (this.items[length / 2 - 1][key] + this.items[length / 2][key]) / 2;
  }

  return this.items[Math.floor(length / 2)][key];
};

var merge = function merge(value) {
  var arrayOrObject = value;

  if (typeof arrayOrObject === 'string') {
    arrayOrObject = [arrayOrObject];
  }

  if (Array.isArray(this.items) && Array.isArray(arrayOrObject)) {
    return new this.constructor(this.items.concat(arrayOrObject));
  }

  var collection = JSON.parse(JSON.stringify(this.items));
  Object.keys(arrayOrObject).forEach(function (key) {
    collection[key] = arrayOrObject[key];
  });
  return new this.constructor(collection);
};

function _typeof$4(obj) { "@babel/helpers - typeof"; return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$4(obj); }

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty$3(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var mergeRecursive = function mergeRecursive(items) {
  var merge = function merge(target, source) {
    var merged = {};
    var mergedKeys = Object.keys(_objectSpread$3(_objectSpread$3({}, target), source));
    mergedKeys.forEach(function (key) {
      if (target[key] === undefined && source[key] !== undefined) {
        merged[key] = source[key];
      } else if (target[key] !== undefined && source[key] === undefined) {
        merged[key] = target[key];
      } else if (target[key] !== undefined && source[key] !== undefined) {
        if (target[key] === source[key]) {
          merged[key] = target[key];
        } else if (!Array.isArray(target[key]) && _typeof$4(target[key]) === 'object' && !Array.isArray(source[key]) && _typeof$4(source[key]) === 'object') {
          merged[key] = merge(target[key], source[key]);
        } else {
          merged[key] = [].concat(target[key], source[key]);
        }
      }
    });
    return merged;
  };

  if (!items) {
    return this;
  }

  if (items.constructor.name === 'Collection') {
    return new this.constructor(merge(this.items, items.all()));
  }

  return new this.constructor(merge(this.items, items));
};

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var min = function min(key) {
  if (key !== undefined) {
    var filtered = this.items.filter(function (item) {
      return item[key] !== undefined;
    });
    return Math.min.apply(Math, _toConsumableArray(filtered.map(function (item) {
      return item[key];
    })));
  }

  return Math.min.apply(Math, _toConsumableArray(this.items));
};

var mode = function mode(key) {
  var values = [];
  var highestCount = 1;

  if (!this.items.length) {
    return null;
  }

  this.items.forEach(function (item) {
    var tempValues = values.filter(function (value) {
      if (key !== undefined) {
        return value.key === item[key];
      }

      return value.key === item;
    });

    if (!tempValues.length) {
      if (key !== undefined) {
        values.push({
          key: item[key],
          count: 1
        });
      } else {
        values.push({
          key: item,
          count: 1
        });
      }
    } else {
      tempValues[0].count += 1;
      var count = tempValues[0].count;

      if (count > highestCount) {
        highestCount = count;
      }
    }
  });
  return values.filter(function (value) {
    return value.count === highestCount;
  }).map(function (value) {
    return value.key;
  });
};

var values$5 = values$8;

var nth = function nth(n) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var items = values$5(this.items);
  var collection = items.slice(offset).filter(function (item, index) {
    return index % n === 0;
  });
  return new this.constructor(collection);
};

var variadic$1 = variadic$4;

var only = function only() {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var properties = variadic$1(args);

  if (Array.isArray(this.items)) {
    var _collection = this.items.filter(function (item) {
      return properties.indexOf(item) !== -1;
    });

    return new this.constructor(_collection);
  }

  var collection = {};
  Object.keys(this.items).forEach(function (prop) {
    if (properties.indexOf(prop) !== -1) {
      collection[prop] = _this.items[prop];
    }
  });
  return new this.constructor(collection);
};

var clone = clone$2;

var pad = function pad(size, value) {
  var abs = Math.abs(size);
  var count = this.count();

  if (abs <= count) {
    return this;
  }

  var diff = abs - count;
  var items = clone(this.items);
  var isArray = Array.isArray(this.items);
  var prepend = size < 0;

  for (var iterator = 0; iterator < diff;) {
    if (!isArray) {
      if (items[iterator] !== undefined) {
        diff += 1;
      } else {
        items[iterator] = value;
      }
    } else if (prepend) {
      items.unshift(value);
    } else {
      items.push(value);
    }

    iterator += 1;
  }

  return new this.constructor(items);
};

var partition = function partition(fn) {
  var _this = this;

  var arrays;

  if (Array.isArray(this.items)) {
    arrays = [new this.constructor([]), new this.constructor([])];
    this.items.forEach(function (item) {
      if (fn(item) === true) {
        arrays[0].push(item);
      } else {
        arrays[1].push(item);
      }
    });
  } else {
    arrays = [new this.constructor({}), new this.constructor({})];
    Object.keys(this.items).forEach(function (prop) {
      var value = _this.items[prop];

      if (fn(value) === true) {
        arrays[0].put(prop, value);
      } else {
        arrays[1].put(prop, value);
      }
    });
  }

  return new this.constructor(arrays);
};

var pipe = function pipe(fn) {
  return fn(this);
};

var _require$d = is,
    isArray$7 = _require$d.isArray,
    isObject$8 = _require$d.isObject;

var nestedValue$5 = nestedValue$8;

var buildKeyPathMap = function buildKeyPathMap(items) {
  var keyPaths = {};
  items.forEach(function (item, index) {
    function buildKeyPath(val, keyPath) {
      if (isObject$8(val)) {
        Object.keys(val).forEach(function (prop) {
          buildKeyPath(val[prop], "".concat(keyPath, ".").concat(prop));
        });
      } else if (isArray$7(val)) {
        val.forEach(function (v, i) {
          buildKeyPath(v, "".concat(keyPath, ".").concat(i));
        });
      }

      keyPaths[keyPath] = val;
    }

    buildKeyPath(item, index);
  });
  return keyPaths;
};

var pluck = function pluck(value, key) {
  if (value.indexOf('*') !== -1) {
    var keyPathMap = buildKeyPathMap(this.items);
    var keyMatches = [];

    if (key !== undefined) {
      var keyRegex = new RegExp("0.".concat(key), 'g');
      var keyNumberOfLevels = "0.".concat(key).split('.').length;
      Object.keys(keyPathMap).forEach(function (k) {
        var matchingKey = k.match(keyRegex);

        if (matchingKey) {
          var match = matchingKey[0];

          if (match.split('.').length === keyNumberOfLevels) {
            keyMatches.push(keyPathMap[match]);
          }
        }
      });
    }

    var valueMatches = [];
    var valueRegex = new RegExp("0.".concat(value), 'g');
    var valueNumberOfLevels = "0.".concat(value).split('.').length;
    Object.keys(keyPathMap).forEach(function (k) {
      var matchingValue = k.match(valueRegex);

      if (matchingValue) {
        var match = matchingValue[0];

        if (match.split('.').length === valueNumberOfLevels) {
          valueMatches.push(keyPathMap[match]);
        }
      }
    });

    if (key !== undefined) {
      var collection = {};
      this.items.forEach(function (item, index) {
        collection[keyMatches[index] || ''] = valueMatches;
      });
      return new this.constructor(collection);
    }

    return new this.constructor([valueMatches]);
  }

  if (key !== undefined) {
    var _collection = {};
    this.items.forEach(function (item) {
      if (nestedValue$5(item, value) !== undefined) {
        _collection[item[key] || ''] = nestedValue$5(item, value);
      } else {
        _collection[item[key] || ''] = null;
      }
    });
    return new this.constructor(_collection);
  }

  return this.map(function (item) {
    if (nestedValue$5(item, value) !== undefined) {
      return nestedValue$5(item, value);
    }

    return null;
  });
};

var variadic = variadic$4;
/**
 * Delete keys helper
 *
 * Delete one or multiple keys from an object
 *
 * @param obj
 * @param keys
 * @returns {void}
 */


var deleteKeys$2 = function deleteKeys(obj) {
  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  variadic(keys).forEach(function (key) {
    // eslint-disable-next-line
    delete obj[key];
  });
};

var _require$c = is,
    isArray$6 = _require$c.isArray,
    isObject$7 = _require$c.isObject;

var deleteKeys$1 = deleteKeys$2;

var pop = function pop() {
  var _this = this;

  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

  if (this.isEmpty()) {
    return null;
  }

  if (isArray$6(this.items)) {
    if (count === 1) {
      return this.items.pop();
    }

    return new this.constructor(this.items.splice(-count));
  }

  if (isObject$7(this.items)) {
    var keys = Object.keys(this.items);

    if (count === 1) {
      var key = keys[keys.length - 1];
      var last = this.items[key];
      deleteKeys$1(this.items, key);
      return last;
    }

    var poppedKeys = keys.slice(-count);
    var newObject = poppedKeys.reduce(function (acc, current) {
      acc[current] = _this.items[current];
      return acc;
    }, {});
    deleteKeys$1(this.items, poppedKeys);
    return new this.constructor(newObject);
  }

  return null;
};

var prepend = function prepend(value, key) {
  if (key !== undefined) {
    return this.put(key, value);
  }

  this.items.unshift(value);
  return this;
};

var _require$b = is,
    isFunction$9 = _require$b.isFunction;

var pull = function pull(key, defaultValue) {
  var returnValue = this.items[key] || null;

  if (!returnValue && defaultValue !== undefined) {
    if (isFunction$9(defaultValue)) {
      returnValue = defaultValue();
    } else {
      returnValue = defaultValue;
    }
  }

  delete this.items[key];
  return returnValue;
};

var push = function push() {
  var _this$items;

  (_this$items = this.items).push.apply(_this$items, arguments);

  return this;
};

var put = function put(key, value) {
  this.items[key] = value;
  return this;
};

var values$4 = values$8;

var random = function random() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var items = values$4(this.items);
  var collection = new this.constructor(items).shuffle(); // If not a length was specified

  if (length !== parseInt(length, 10)) {
    return collection.first();
  }

  return collection.take(length);
};

var reduce = function reduce(fn, carry) {
  var _this = this;

  var reduceCarry = null;

  if (carry !== undefined) {
    reduceCarry = carry;
  }

  if (Array.isArray(this.items)) {
    this.items.forEach(function (item) {
      reduceCarry = fn(reduceCarry, item);
    });
  } else {
    Object.keys(this.items).forEach(function (key) {
      reduceCarry = fn(reduceCarry, _this.items[key], key);
    });
  }

  return reduceCarry;
};

var reject = function reject(fn) {
  return new this.constructor(this.items).filter(function (item) {
    return !fn(item);
  });
};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var replace = function replace(items) {
  if (!items) {
    return this;
  }

  if (Array.isArray(items)) {
    var _replaced = this.items.map(function (value, index) {
      return items[index] || value;
    });

    return new this.constructor(_replaced);
  }

  if (items.constructor.name === 'Collection') {
    var _replaced2 = _objectSpread$2(_objectSpread$2({}, this.items), items.all());

    return new this.constructor(_replaced2);
  }

  var replaced = _objectSpread$2(_objectSpread$2({}, this.items), items);

  return new this.constructor(replaced);
};

function _typeof$3(obj) { "@babel/helpers - typeof"; return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$3(obj); }

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty$1(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var replaceRecursive = function replaceRecursive(items) {
  var replace = function replace(target, source) {
    var replaced = _objectSpread$1({}, target);

    var mergedKeys = Object.keys(_objectSpread$1(_objectSpread$1({}, target), source));
    mergedKeys.forEach(function (key) {
      if (!Array.isArray(source[key]) && _typeof$3(source[key]) === 'object') {
        replaced[key] = replace(target[key], source[key]);
      } else if (target[key] === undefined && source[key] !== undefined) {
        if (_typeof$3(target[key]) === 'object') {
          replaced[key] = _objectSpread$1({}, source[key]);
        } else {
          replaced[key] = source[key];
        }
      } else if (target[key] !== undefined && source[key] === undefined) {
        if (_typeof$3(target[key]) === 'object') {
          replaced[key] = _objectSpread$1({}, target[key]);
        } else {
          replaced[key] = target[key];
        }
      } else if (target[key] !== undefined && source[key] !== undefined) {
        if (_typeof$3(source[key]) === 'object') {
          replaced[key] = _objectSpread$1({}, source[key]);
        } else {
          replaced[key] = source[key];
        }
      }
    });
    return replaced;
  };

  if (!items) {
    return this;
  }

  if (!Array.isArray(items) && _typeof$3(items) !== 'object') {
    return new this.constructor(replace(this.items, [items]));
  }

  if (items.constructor.name === 'Collection') {
    return new this.constructor(replace(this.items, items.all()));
  }

  return new this.constructor(replace(this.items, items));
};

var reverse = function reverse() {
  var collection = [].concat(this.items).reverse();
  return new this.constructor(collection);
};

/* eslint-disable eqeqeq */

var _require$a = is,
    isArray$5 = _require$a.isArray,
    isObject$6 = _require$a.isObject,
    isFunction$8 = _require$a.isFunction;

var search = function search(valueOrFunction, strict) {
  var _this = this;

  var result;

  var find = function find(item, key) {
    if (isFunction$8(valueOrFunction)) {
      return valueOrFunction(_this.items[key], key);
    }

    if (strict) {
      return _this.items[key] === valueOrFunction;
    }

    return _this.items[key] == valueOrFunction;
  };

  if (isArray$5(this.items)) {
    result = this.items.findIndex(find);
  } else if (isObject$6(this.items)) {
    result = Object.keys(this.items).find(function (key) {
      return find(_this.items[key], key);
    });
  }

  if (result === undefined || result < 0) {
    return false;
  }

  return result;
};

var _require$9 = is,
    isArray$4 = _require$9.isArray,
    isObject$5 = _require$9.isObject;

var deleteKeys = deleteKeys$2;

var shift = function shift() {
  var _this = this;

  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

  if (this.isEmpty()) {
    return null;
  }

  if (isArray$4(this.items)) {
    if (count === 1) {
      return this.items.shift();
    }

    return new this.constructor(this.items.splice(0, count));
  }

  if (isObject$5(this.items)) {
    if (count === 1) {
      var key = Object.keys(this.items)[0];
      var value = this.items[key];
      delete this.items[key];
      return value;
    }

    var keys = Object.keys(this.items);
    var poppedKeys = keys.slice(0, count);
    var newObject = poppedKeys.reduce(function (acc, current) {
      acc[current] = _this.items[current];
      return acc;
    }, {});
    deleteKeys(this.items, poppedKeys);
    return new this.constructor(newObject);
  }

  return null;
};

var values$3 = values$8;

var shuffle = function shuffle() {
  var items = values$3(this.items);
  var j;
  var x;
  var i;

  for (i = items.length; i; i -= 1) {
    j = Math.floor(Math.random() * i);
    x = items[i - 1];
    items[i - 1] = items[j];
    items[j] = x;
  }

  this.items = items;
  return this;
};

var _require$8 = is,
    isObject$4 = _require$8.isObject;

var skip = function skip(number) {
  var _this = this;

  if (isObject$4(this.items)) {
    return new this.constructor(Object.keys(this.items).reduce(function (accumulator, key, index) {
      if (index + 1 > number) {
        accumulator[key] = _this.items[key];
      }

      return accumulator;
    }, {}));
  }

  return new this.constructor(this.items.slice(number));
};

var _require$7 = is,
    isArray$3 = _require$7.isArray,
    isObject$3 = _require$7.isObject,
    isFunction$7 = _require$7.isFunction;

var skipUntil = function skipUntil(valueOrFunction) {
  var _this = this;

  var previous = null;
  var items;

  var callback = function callback(value) {
    return value === valueOrFunction;
  };

  if (isFunction$7(valueOrFunction)) {
    callback = valueOrFunction;
  }

  if (isArray$3(this.items)) {
    items = this.items.filter(function (item) {
      if (previous !== true) {
        previous = callback(item);
      }

      return previous;
    });
  }

  if (isObject$3(this.items)) {
    items = Object.keys(this.items).reduce(function (acc, key) {
      if (previous !== true) {
        previous = callback(_this.items[key]);
      }

      if (previous !== false) {
        acc[key] = _this.items[key];
      }

      return acc;
    }, {});
  }

  return new this.constructor(items);
};

var _require$6 = is,
    isArray$2 = _require$6.isArray,
    isObject$2 = _require$6.isObject,
    isFunction$6 = _require$6.isFunction;

var skipWhile = function skipWhile(valueOrFunction) {
  var _this = this;

  var previous = null;
  var items;

  var callback = function callback(value) {
    return value === valueOrFunction;
  };

  if (isFunction$6(valueOrFunction)) {
    callback = valueOrFunction;
  }

  if (isArray$2(this.items)) {
    items = this.items.filter(function (item) {
      if (previous !== true) {
        previous = !callback(item);
      }

      return previous;
    });
  }

  if (isObject$2(this.items)) {
    items = Object.keys(this.items).reduce(function (acc, key) {
      if (previous !== true) {
        previous = !callback(_this.items[key]);
      }

      if (previous !== false) {
        acc[key] = _this.items[key];
      }

      return acc;
    }, {});
  }

  return new this.constructor(items);
};

var slice = function slice(remove, limit) {
  var collection = this.items.slice(remove);

  if (limit !== undefined) {
    collection = collection.slice(0, limit);
  }

  return new this.constructor(collection);
};

var _require$5 = is,
    isFunction$5 = _require$5.isFunction;

var sole = function sole(key, operator, value) {
  var collection;

  if (isFunction$5(key)) {
    collection = this.filter(key);
  } else {
    collection = this.where(key, operator, value);
  }

  if (collection.isEmpty()) {
    throw new Error('Item not found.');
  }

  if (collection.count() > 1) {
    throw new Error('Multiple items found.');
  }

  return collection.first();
};

var contains = contains$1;

var some = contains;

var sort = function sort(fn) {
  var collection = [].concat(this.items);

  if (fn === undefined) {
    if (this.every(function (item) {
      return typeof item === 'number';
    })) {
      collection.sort(function (a, b) {
        return a - b;
      });
    } else {
      collection.sort();
    }
  } else {
    collection.sort(fn);
  }

  return new this.constructor(collection);
};

var sortDesc = function sortDesc() {
  return this.sort().reverse();
};

var nestedValue$4 = nestedValue$8;

var _require$4 = is,
    isFunction$4 = _require$4.isFunction;

var sortBy = function sortBy(valueOrFunction) {
  var collection = [].concat(this.items);

  var getValue = function getValue(item) {
    if (isFunction$4(valueOrFunction)) {
      return valueOrFunction(item);
    }

    return nestedValue$4(item, valueOrFunction);
  };

  collection.sort(function (a, b) {
    var valueA = getValue(a);
    var valueB = getValue(b);

    if (valueA === null || valueA === undefined) {
      return 1;
    }

    if (valueB === null || valueB === undefined) {
      return -1;
    }

    if (valueA < valueB) {
      return -1;
    }

    if (valueA > valueB) {
      return 1;
    }

    return 0;
  });
  return new this.constructor(collection);
};

var sortByDesc = function sortByDesc(valueOrFunction) {
  return this.sortBy(valueOrFunction).reverse();
};

var sortKeys = function sortKeys() {
  var _this = this;

  var ordered = {};
  Object.keys(this.items).sort().forEach(function (key) {
    ordered[key] = _this.items[key];
  });
  return new this.constructor(ordered);
};

var sortKeysDesc = function sortKeysDesc() {
  var _this = this;

  var ordered = {};
  Object.keys(this.items).sort().reverse().forEach(function (key) {
    ordered[key] = _this.items[key];
  });
  return new this.constructor(ordered);
};

var splice = function splice(index, limit, replace) {
  var slicedCollection = this.slice(index, limit);
  this.items = this.diff(slicedCollection.all()).all();

  if (Array.isArray(replace)) {
    for (var iterator = 0, length = replace.length; iterator < length; iterator += 1) {
      this.items.splice(index + iterator, 0, replace[iterator]);
    }
  }

  return slicedCollection;
};

var split = function split(numberOfGroups) {
  var itemsPerGroup = Math.round(this.items.length / numberOfGroups);
  var items = JSON.parse(JSON.stringify(this.items));
  var collection = [];

  for (var iterator = 0; iterator < numberOfGroups; iterator += 1) {
    collection.push(new this.constructor(items.splice(0, itemsPerGroup)));
  }

  return new this.constructor(collection);
};

var values$2 = values$8;

var _require$3 = is,
    isFunction$3 = _require$3.isFunction;

var sum = function sum(key) {
  var items = values$2(this.items);
  var total = 0;

  if (key === undefined) {
    for (var i = 0, length = items.length; i < length; i += 1) {
      total += parseFloat(items[i]);
    }
  } else if (isFunction$3(key)) {
    for (var _i = 0, _length = items.length; _i < _length; _i += 1) {
      total += parseFloat(key(items[_i]));
    }
  } else {
    for (var _i2 = 0, _length2 = items.length; _i2 < _length2; _i2 += 1) {
      total += parseFloat(items[_i2][key]);
    }
  }

  return parseFloat(total.toPrecision(12));
};

function _typeof$2(obj) { "@babel/helpers - typeof"; return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$2(obj); }

var take = function take(length) {
  var _this = this;

  if (!Array.isArray(this.items) && _typeof$2(this.items) === 'object') {
    var keys = Object.keys(this.items);
    var slicedKeys;

    if (length < 0) {
      slicedKeys = keys.slice(length);
    } else {
      slicedKeys = keys.slice(0, length);
    }

    var collection = {};
    keys.forEach(function (prop) {
      if (slicedKeys.indexOf(prop) !== -1) {
        collection[prop] = _this.items[prop];
      }
    });
    return new this.constructor(collection);
  }

  if (length < 0) {
    return new this.constructor(this.items.slice(length));
  }

  return new this.constructor(this.items.slice(0, length));
};

var _require$2 = is,
    isArray$1 = _require$2.isArray,
    isObject$1 = _require$2.isObject,
    isFunction$2 = _require$2.isFunction;

var takeUntil = function takeUntil(valueOrFunction) {
  var _this = this;

  var previous = null;
  var items;

  var callback = function callback(value) {
    return value === valueOrFunction;
  };

  if (isFunction$2(valueOrFunction)) {
    callback = valueOrFunction;
  }

  if (isArray$1(this.items)) {
    items = this.items.filter(function (item) {
      if (previous !== false) {
        previous = !callback(item);
      }

      return previous;
    });
  }

  if (isObject$1(this.items)) {
    items = Object.keys(this.items).reduce(function (acc, key) {
      if (previous !== false) {
        previous = !callback(_this.items[key]);
      }

      if (previous !== false) {
        acc[key] = _this.items[key];
      }

      return acc;
    }, {});
  }

  return new this.constructor(items);
};

var _require$1 = is,
    isArray = _require$1.isArray,
    isObject = _require$1.isObject,
    isFunction$1 = _require$1.isFunction;

var takeWhile = function takeWhile(valueOrFunction) {
  var _this = this;

  var previous = null;
  var items;

  var callback = function callback(value) {
    return value === valueOrFunction;
  };

  if (isFunction$1(valueOrFunction)) {
    callback = valueOrFunction;
  }

  if (isArray(this.items)) {
    items = this.items.filter(function (item) {
      if (previous !== false) {
        previous = callback(item);
      }

      return previous;
    });
  }

  if (isObject(this.items)) {
    items = Object.keys(this.items).reduce(function (acc, key) {
      if (previous !== false) {
        previous = callback(_this.items[key]);
      }

      if (previous !== false) {
        acc[key] = _this.items[key];
      }

      return acc;
    }, {});
  }

  return new this.constructor(items);
};

var tap = function tap(fn) {
  fn(this);
  return this;
};

var times = function times(n, fn) {
  for (var iterator = 1; iterator <= n; iterator += 1) {
    this.items.push(fn(iterator));
  }

  return this;
};

var toArray = function toArray() {
  var collectionInstance = this.constructor;

  function iterate(list, collection) {
    var childCollection = [];

    if (list instanceof collectionInstance) {
      list.items.forEach(function (i) {
        return iterate(i, childCollection);
      });
      collection.push(childCollection);
    } else if (Array.isArray(list)) {
      list.forEach(function (i) {
        return iterate(i, childCollection);
      });
      collection.push(childCollection);
    } else {
      collection.push(list);
    }
  }

  if (Array.isArray(this.items)) {
    var collection = [];
    this.items.forEach(function (items) {
      iterate(items, collection);
    });
    return collection;
  }

  return this.values().all();
};

function _typeof$1(obj) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$1(obj); }

var toJson = function toJson() {
  if (_typeof$1(this.items) === 'object' && !Array.isArray(this.items)) {
    return JSON.stringify(this.all());
  }

  return JSON.stringify(this.toArray());
};

var transform = function transform(fn) {
  var _this = this;

  if (Array.isArray(this.items)) {
    this.items = this.items.map(fn);
  } else {
    var collection = {};
    Object.keys(this.items).forEach(function (key) {
      collection[key] = fn(_this.items[key], key);
    });
    this.items = collection;
  }

  return this;
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var undot = function undot() {
  var _this = this;

  if (Array.isArray(this.items)) {
    return this;
  }

  var collection = {};
  Object.keys(this.items).forEach(function (key) {
    if (key.indexOf('.') !== -1) {
      var obj = collection;
      key.split('.').reduce(function (acc, current, index, array) {
        if (!acc[current]) {
          acc[current] = {};
        }

        if (index === array.length - 1) {
          acc[current] = _this.items[key];
        }

        return acc[current];
      }, obj);
      collection = _objectSpread(_objectSpread({}, collection), obj);
    } else {
      collection[key] = _this.items[key];
    }
  });
  return new this.constructor(collection);
};

var unless = function when(value, fn, defaultFn) {
  if (!value) {
    fn(this);
  } else {
    defaultFn(this);
  }
};

var whenNotEmpty = function whenNotEmpty(fn, defaultFn) {
  if (Array.isArray(this.items) && this.items.length) {
    return fn(this);
  }

  if (Object.keys(this.items).length) {
    return fn(this);
  }

  if (defaultFn !== undefined) {
    if (Array.isArray(this.items) && !this.items.length) {
      return defaultFn(this);
    }

    if (!Object.keys(this.items).length) {
      return defaultFn(this);
    }
  }

  return this;
};

var whenEmpty = function whenEmpty(fn, defaultFn) {
  if (Array.isArray(this.items) && !this.items.length) {
    return fn(this);
  }

  if (!Object.keys(this.items).length) {
    return fn(this);
  }

  if (defaultFn !== undefined) {
    if (Array.isArray(this.items) && this.items.length) {
      return defaultFn(this);
    }

    if (Object.keys(this.items).length) {
      return defaultFn(this);
    }
  }

  return this;
};

var union = function union(object) {
  var _this = this;

  var collection = JSON.parse(JSON.stringify(this.items));
  Object.keys(object).forEach(function (prop) {
    if (_this.items[prop] === undefined) {
      collection[prop] = object[prop];
    }
  });
  return new this.constructor(collection);
};

var _require = is,
    isFunction = _require.isFunction;

var unique = function unique(key) {
  var collection;

  if (key === undefined) {
    collection = this.items.filter(function (element, index, self) {
      return self.indexOf(element) === index;
    });
  } else {
    collection = [];
    var usedKeys = [];

    for (var iterator = 0, length = this.items.length; iterator < length; iterator += 1) {
      var uniqueKey = void 0;

      if (isFunction(key)) {
        uniqueKey = key(this.items[iterator]);
      } else {
        uniqueKey = this.items[iterator][key];
      }

      if (usedKeys.indexOf(uniqueKey) === -1) {
        collection.push(this.items[iterator]);
        usedKeys.push(uniqueKey);
      }
    }
  }

  return new this.constructor(collection);
};

var unwrap = function unwrap(value) {
  if (value instanceof this.constructor) {
    return value.all();
  }

  return value;
};

var getValues = values$8;

var values$1 = function values() {
  return new this.constructor(getValues(this.items));
};

var when = function when(value, fn, defaultFn) {
  if (value) {
    return fn(this, value);
  }

  if (defaultFn) {
    return defaultFn(this, value);
  }

  return this;
};

var values = values$8;

var nestedValue$3 = nestedValue$8;

var where = function where(key, operator, value) {
  var comparisonOperator = operator;
  var comparisonValue = value;
  var items = values(this.items);

  if (operator === undefined || operator === true) {
    return new this.constructor(items.filter(function (item) {
      return nestedValue$3(item, key);
    }));
  }

  if (operator === false) {
    return new this.constructor(items.filter(function (item) {
      return !nestedValue$3(item, key);
    }));
  }

  if (value === undefined) {
    comparisonValue = operator;
    comparisonOperator = '===';
  }

  var collection = items.filter(function (item) {
    switch (comparisonOperator) {
      case '==':
        return nestedValue$3(item, key) === Number(comparisonValue) || nestedValue$3(item, key) === comparisonValue.toString();

      default:
      case '===':
        return nestedValue$3(item, key) === comparisonValue;

      case '!=':
      case '<>':
        return nestedValue$3(item, key) !== Number(comparisonValue) && nestedValue$3(item, key) !== comparisonValue.toString();

      case '!==':
        return nestedValue$3(item, key) !== comparisonValue;

      case '<':
        return nestedValue$3(item, key) < comparisonValue;

      case '<=':
        return nestedValue$3(item, key) <= comparisonValue;

      case '>':
        return nestedValue$3(item, key) > comparisonValue;

      case '>=':
        return nestedValue$3(item, key) >= comparisonValue;
    }
  });
  return new this.constructor(collection);
};

var whereBetween = function whereBetween(key, values) {
  return this.where(key, '>=', values[0]).where(key, '<=', values[values.length - 1]);
};

var extractValues$1 = values$8;

var nestedValue$2 = nestedValue$8;

var whereIn = function whereIn(key, values) {
  var items = extractValues$1(values);
  var collection = this.items.filter(function (item) {
    return items.indexOf(nestedValue$2(item, key)) !== -1;
  });
  return new this.constructor(collection);
};

var whereInstanceOf = function whereInstanceOf(type) {
  return this.filter(function (item) {
    return item instanceof type;
  });
};

var nestedValue$1 = nestedValue$8;

var whereNotBetween = function whereNotBetween(key, values) {
  return this.filter(function (item) {
    return nestedValue$1(item, key) < values[0] || nestedValue$1(item, key) > values[values.length - 1];
  });
};

var extractValues = values$8;

var nestedValue = nestedValue$8;

var whereNotIn = function whereNotIn(key, values) {
  var items = extractValues(values);
  var collection = this.items.filter(function (item) {
    return items.indexOf(nestedValue(item, key)) === -1;
  });
  return new this.constructor(collection);
};

var whereNull = function whereNull() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return this.where(key, '===', null);
};

var whereNotNull = function whereNotNull() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return this.where(key, '!==', null);
};

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var wrap = function wrap(value) {
  if (value instanceof this.constructor) {
    return value;
  }

  if (_typeof(value) === 'object') {
    return new this.constructor(value);
  }

  return new this.constructor([value]);
};

var zip = function zip(array) {
  var _this = this;

  var values = array;

  if (values instanceof this.constructor) {
    values = values.all();
  }

  var collection = this.items.map(function (item, index) {
    return new _this.constructor([item, values[index]]);
  });
  return new this.constructor(collection);
};

(function (module) {

	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

	function Collection(collection) {
	  if (collection !== undefined && !Array.isArray(collection) && _typeof(collection) !== 'object') {
	    this.items = [collection];
	  } else if (collection instanceof this.constructor) {
	    this.items = collection.all();
	  } else {
	    this.items = collection || [];
	  }
	}
	/**
	 * Symbol.iterator
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator
	 */


	var SymbolIterator = symbol_iterator;

	if (typeof Symbol !== 'undefined') {
	  Collection.prototype[Symbol.iterator] = SymbolIterator;
	}
	/**
	 * Support JSON.stringify
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
	 */


	Collection.prototype.toJSON = function toJSON() {
	  return this.items;
	};

	Collection.prototype.all = all;
	Collection.prototype.average = average$1;
	Collection.prototype.avg = avg;
	Collection.prototype.chunk = chunk;
	Collection.prototype.collapse = collapse;
	Collection.prototype.combine = combine;
	Collection.prototype.concat = concat;
	Collection.prototype.contains = contains$1;
	Collection.prototype.containsOneItem = containsOneItem;
	Collection.prototype.count = count;
	Collection.prototype.countBy = countBy;
	Collection.prototype.crossJoin = crossJoin;
	Collection.prototype.dd = dd;
	Collection.prototype.diff = diff;
	Collection.prototype.diffAssoc = diffAssoc;
	Collection.prototype.diffKeys = diffKeys;
	Collection.prototype.diffUsing = diffUsing;
	Collection.prototype.doesntContain = doesntContain;
	Collection.prototype.dump = dump;
	Collection.prototype.duplicates = duplicates;
	Collection.prototype.each = each;
	Collection.prototype.eachSpread = eachSpread;
	Collection.prototype.every = every;
	Collection.prototype.except = except;
	Collection.prototype.filter = filter;
	Collection.prototype.first = first;
	Collection.prototype.firstOrFail = firstOrFail;
	Collection.prototype.firstWhere = firstWhere;
	Collection.prototype.flatMap = flatMap;
	Collection.prototype.flatten = flatten;
	Collection.prototype.flip = flip;
	Collection.prototype.forPage = forPage;
	Collection.prototype.forget = forget;
	Collection.prototype.get = get;
	Collection.prototype.groupBy = groupBy;
	Collection.prototype.has = has;
	Collection.prototype.implode = implode;
	Collection.prototype.intersect = intersect;
	Collection.prototype.intersectByKeys = intersectByKeys;
	Collection.prototype.isEmpty = isEmpty;
	Collection.prototype.isNotEmpty = isNotEmpty;
	Collection.prototype.join = join;
	Collection.prototype.keyBy = keyBy;
	Collection.prototype.keys = keys;
	Collection.prototype.last = last;
	Collection.prototype.macro = macro;
	Collection.prototype.make = make;
	Collection.prototype.map = map;
	Collection.prototype.mapSpread = mapSpread;
	Collection.prototype.mapToDictionary = mapToDictionary;
	Collection.prototype.mapInto = mapInto;
	Collection.prototype.mapToGroups = mapToGroups;
	Collection.prototype.mapWithKeys = mapWithKeys;
	Collection.prototype.max = max;
	Collection.prototype.median = median;
	Collection.prototype.merge = merge;
	Collection.prototype.mergeRecursive = mergeRecursive;
	Collection.prototype.min = min;
	Collection.prototype.mode = mode;
	Collection.prototype.nth = nth;
	Collection.prototype.only = only;
	Collection.prototype.pad = pad;
	Collection.prototype.partition = partition;
	Collection.prototype.pipe = pipe;
	Collection.prototype.pluck = pluck;
	Collection.prototype.pop = pop;
	Collection.prototype.prepend = prepend;
	Collection.prototype.pull = pull;
	Collection.prototype.push = push;
	Collection.prototype.put = put;
	Collection.prototype.random = random;
	Collection.prototype.reduce = reduce;
	Collection.prototype.reject = reject;
	Collection.prototype.replace = replace;
	Collection.prototype.replaceRecursive = replaceRecursive;
	Collection.prototype.reverse = reverse;
	Collection.prototype.search = search;
	Collection.prototype.shift = shift;
	Collection.prototype.shuffle = shuffle;
	Collection.prototype.skip = skip;
	Collection.prototype.skipUntil = skipUntil;
	Collection.prototype.skipWhile = skipWhile;
	Collection.prototype.slice = slice;
	Collection.prototype.sole = sole;
	Collection.prototype.some = some;
	Collection.prototype.sort = sort;
	Collection.prototype.sortDesc = sortDesc;
	Collection.prototype.sortBy = sortBy;
	Collection.prototype.sortByDesc = sortByDesc;
	Collection.prototype.sortKeys = sortKeys;
	Collection.prototype.sortKeysDesc = sortKeysDesc;
	Collection.prototype.splice = splice;
	Collection.prototype.split = split;
	Collection.prototype.sum = sum;
	Collection.prototype.take = take;
	Collection.prototype.takeUntil = takeUntil;
	Collection.prototype.takeWhile = takeWhile;
	Collection.prototype.tap = tap;
	Collection.prototype.times = times;
	Collection.prototype.toArray = toArray;
	Collection.prototype.toJson = toJson;
	Collection.prototype.transform = transform;
	Collection.prototype.undot = undot;
	Collection.prototype.unless = unless;
	Collection.prototype.unlessEmpty = whenNotEmpty;
	Collection.prototype.unlessNotEmpty = whenEmpty;
	Collection.prototype.union = union;
	Collection.prototype.unique = unique;
	Collection.prototype.unwrap = unwrap;
	Collection.prototype.values = values$1;
	Collection.prototype.when = when;
	Collection.prototype.whenEmpty = whenEmpty;
	Collection.prototype.whenNotEmpty = whenNotEmpty;
	Collection.prototype.where = where;
	Collection.prototype.whereBetween = whereBetween;
	Collection.prototype.whereIn = whereIn;
	Collection.prototype.whereInstanceOf = whereInstanceOf;
	Collection.prototype.whereNotBetween = whereNotBetween;
	Collection.prototype.whereNotIn = whereNotIn;
	Collection.prototype.whereNull = whereNull;
	Collection.prototype.whereNotNull = whereNotNull;
	Collection.prototype.wrap = wrap;
	Collection.prototype.zip = zip;

	var collect = function collect(collection) {
	  return new Collection(collection);
	};

	module.exports = collect;
	module.exports.collect = collect;
	module.exports["default"] = collect;
	module.exports.Collection = Collection; 
} (dist));

var distExports = dist.exports;
var collect = /*@__PURE__*/getDefaultExportFromCjs(distExports);

var lines =  [];

const bezier = (div1,div2) =>{
    const rect1 = div1.getBoundingClientRect();
    const rect2 = div2.getBoundingClientRect();
    let x1 = rect1.left + rect1.width / 2;
    let y1 = rect1.top + rect1.height / 2;
    let x2 = rect2.left + rect2.width / 2;
    let y2 = rect2.top + rect2.height / 2;
   
    return {x1:x1,y1:y1,x2:x2,y2:y2,controlX:(x1 + x2) / 2,controlY:y1 - 50}
};


const hasLine = (div1,div2) =>{
  return collect(lines).firstWhere('div2',div1) == null ? false : true; 
};

// This function receive two DOM elements to calcule the distance then draw the line 
const pathLine = (div1,div2) =>{ 
  if(div2 === null){
    document.getElementById('new_path').removeAttribute('d');
    return;
  }
  let be = bezier(div1,div2);
    
  document.getElementById('new_path').setAttribute('d', `M${be.x1},${be.y1} Q${be.controlX},${be.controlY} ${be.x2},${be.y2}`);
};
const removePath = () =>{
  let path = document.getElementById('new_path');
  if(path.getAttribute('d')!= null) path.removeAttribute('d');
};

const addLine = (div1,div2) =>{
    let path = document.createElementNS("http://www.w3.org/2000/svg","path");
    path.id = randomStr();
    path.setAttribute("fill","none");
    path.setAttribute("stroke","blue");
    path.setAttribute("stroke-width","6");
    let be = bezier(div1,div2);
    lines.push({id:path.id,div1,div2});
    path.setAttribute('d', `M${be.x1},${be.y1} Q${be.controlX},${be.controlY} ${be.x2},${be.y2}`);
    document.getElementById('lines').appendChild(path);
};


const updateLines = () =>{
  lines.forEach((line,key) => { 
    if(!document.body.contains(line.div1) || !document.body.contains(line.div2)){
      lines.splice(key,1); 
      document.getElementById(line.id).remove();
    }else {
      let be = bezier(line.div1,line.div2);
      document.getElementById(line.id).setAttribute('d', `M${be.x1},${be.y1} Q${be.controlX},${be.controlY} ${be.x2},${be.y2}`);
    }    
  });
};

class Node{

      constructor(data){
        this.data = data;
      }

      draw(){
        let node = document.createElement('div');

        node.className = "node"; 
        node.innerHTML = this.data.name;
        var id = `node_${randomStr()}`;
        node.id = id;

        node.onmousedown = function(e){

          var collided = null;
          node.id = `${id}_dragging`;

          const moveAt = (x,y)=>{
            node.style.left = x - node.offsetWidth/2 + "px";
            node.style.top = y - node.offsetHeight/2 + "px";
          };
          
          function onMouseMove(e){
            moveAt(e.pageX,e.pageY);
            
            updateLines();
            collided = checkCollisions(node);
            if(!hasLine(node)) pathLine(node,collided);
          }

          document.addEventListener('mousemove', onMouseMove);

          node.onmouseup = function() {
            removePath();
            document.removeEventListener('mousemove', onMouseMove);
            node.id = id;
            if(collided !== null && !hasLine(node)){
              addLine(node,collided);
            }
            node.onmouseup = null;var id = `node_${randomStr()}`; 
          };
        }; 
        this.element = node;


        var delete_button = document.createElement('button');
        delete_button.className = 'delete_button';
        delete_button.onclick = () =>{
          node.remove();  
          updateLines();
          updateLines();
        };
        node.appendChild(delete_button);

        return node;
      }

    }

class Canva {

      constructor(){
        this.nodes = [];
      }
      
      setupSvg(){
        let svg = document.createElementNS("http://www.w3.org/2000/svg","svg"); 
        svg.id = "lines";
        svg.style="position: absolute; height:100%; width:100%";

        let path = document.createElementNS("http://www.w3.org/2000/svg","path");

        path.id = "new_path";
        path.setAttribute("fill","none");
        path.setAttribute("stroke","#ddd");
        path.setAttribute("stroke-width","6");
        path.setAttribute("stroke-dasharray","10,6");
        svg.appendChild(path);

        this.svg = svg;
        return svg;
      }

      addNode(no){
        
        let node = new Node(no);
        
        this.canva.appendChild(node.draw());
        this.nodes.push(node);

        console.log(node);
      }

      addNodes(no){ 
        no.forEach((node_obj)=>{
          let node = new Node(node_obj);
          this.canva.appendChild(node.draw()); 
          this.nodes.push(node);
        });
      }

      draw(id){
        let canva = document.createElement("div");
        canva.className = "canva";
        canva.id = "canva";

        canva.appendChild(this.setupSvg());

        document.getElementById("tree").appendChild(canva);
        this.canva = canva;
      }
    
}

var canva = new Canva();

    canva.draw();

    var nodes = [
      {
        name:'teste1',
      },
      {
        name:'teste2',
      },
      {
        name:'teste3'
      }
    ];

    canva.addNodes(nodes);

    var button = document.createElement('button');

    button.onclick = ()=>{
      canva.addNode({name:'testeeeee'});
    };
    button.style="position: absolute; top:2; left:2";
    button.innerHTML = "Adicionar";

    document.getElementById("canva").appendChild(button);


var main = {
  Canva
};

export { main as default };
